#!/usr/bin/env node
const exec = require('child_process').exec;
const spawn = require('child_process').spawn;
const path = require('path');
const events = require('events');
const eventEmitter = new events.EventEmitter();
const AsyncWatch = require('async-watch').AsyncWatch;
const app = require('http').createServer(handler);
const io = require('socket.io')(app);
const fs = require('fs');
const net = require('net');
app.listen(9000);

var prefix = "var data_cntr = ";
var suffix = ";";

var procData = {
	// Save the current line of code
	codeLine: "",
	// Save current child process data
	processData: "",
	// Receive current child process error
	processError: "",
	// Track the beekeeper process
	proc: undefined,
	// Track the disassembly instructions generated by beekeeper
	disassembly: "",
	vcdDump: ""
};

var state = {
	// Whether or not we're in stepping mode
	stepping: false,
	// Count number of steps
	step: 0,
	// Count number of steps
	// Flag to keep track of beekeeper termination
	finished: false,
	// Keep track of whether or not the run has finished
	runningFinished: false
};

var beekeeperData = {
	beekeeperPath: "/usr/local/bin/BeekeeperSupport/",
	socPath: "/usr/local/bin/BeekeeperSupport/Compiler/examplesoc.json",
	makeSocPath: "/usr/local/bin/BeekeeperSupport/makesoc",
	ccPath: "/usr/local/bin/BeekeeperSupport/cc"
}

var userData = {
	codeFileName: "code.c",
	codeCFile: "code.c",
	codeBinFile: "code.c.bin",
	codeTextFile: "./public/data/code-text.js",
	waveformDataFile: "./public/data/waveform-data.js",
	waveformTextFile: "./public/data/waveform-text.js",
	disassemblyTextFile: "./public/data/disassembly.js"
}

// This is the execution chain, follow it from the top down
/*
The following functions run beekeeper and get everything initialized in order
*/
// copySoc Calls makeSoc
eventEmitter.on('codeCompiled', copySoc);
// makeSoc Calls build
eventEmitter.on('socCopied', makeSoc);
// build Calls runBeekeeper
eventEmitter.on('socMade', build);
// runBeekeeper Calls setProcessParams
eventEmitter.on('built', runBeekeeper);
// setProcessParams Calls setBeekeeperDataStream
eventEmitter.on('ranBeekeeper', setProcessParams);
// setBeekeeperDataStream Calls finishCompilation
eventEmitter.on('processParamsSet', setBeekeeperDataStream);
// finishCompilation sends returnCompiled signal through socket.io to frontend
eventEmitter.on('dataStreamDefined', finishCompilation)
/*
The following functions do nothing except communicate with frontend
*/
// codeSaved sends returnSaved signal through socket.io to frontend
eventEmitter.on('codeSaved', finishSave);
// finishRun sends returnRun signal through socket.io to frontend
eventEmitter.on('runFinished', finishRun);
// finishStep sends returnStep signal through socket.io to frontend
eventEmitter.on('stepFinished', storeVCD);
// sendExitSignal sends returnStop signal through socket.io to frontend
eventEmitter.on('stopped', sendExitSignal);

/*
Monitor runningFinished state value for switch.
Only release finishRun() if the value changes.
*/
AsyncWatch(state, 'runningFinished', function(oldValue, newValue){
	if (newValue !== oldValue) {
		// console.log('emitting');
		eventEmitter.emit('runFinished');
	}
});

AsyncWatch(procData, 'vcdDump', function(oldValue, newValue){
	// console.log(procData.vcdDump);
	// var data = ;
	// var count = 0;
	// console.log(data);
	// for (var attribute in data) {
	// 	count++;
	// 	socket.emit('element', attribute, data[attribute]);
		socket.emit('returnRun', procData.vcdDump);
	// }
});

/*
Catch all exceptions to make sure server doesn't crash
TODO exception handling needs to be done properly
*/
process.on('uncaughtException', function (err) {
	console.error(err);
});
/*
Bind the process exit event to our exit handler
*/
process.on('exit', exitHandler.bind(null,{exit:true}));

// so the program will not close instantly
process.stdin.resume();

/*
HTTP server handler
*/
function handler (req, res) {
	fs.readFile(__dirname + '/public/index.html',
		function (err, data) {
			if (err) {
			res.writeHead(500);
			return res.end('Error loading index.html');
		}
		res.writeHead(200);
		res.end(data);
	});
}

/*
Handle the process exit
*/
function exitHandler(options, err) {
    if (options.exit) {
		if (typeof(procData.proc) !== 'undefined') {
			procData.proc.kill();
		}
		socket.emit('message', "Exit");
		process.exit();
	}
}
/*
Store the vcd2waveform data in the user data folder
*/
function storeVCD() {
	var child = spawn('./vcd2js.pl', ['dump.vcd']);
	var output = "";
	child.stdout.on('data', (data) => {
		output += data;
	});
	// Only save when process is finished
	child.stdout.on('close', function(code) {
		// prefix + + suffix
        procData.vcdDump = output;
		var store = prefix + output + suffix;
		storeFile(userData.waveformDataFile, store);
    });
}

/*
Helper function to store files on drive
*/
function storeFile(file, text) {
	fs.writeFile(file, text, function(err) {
		if(err) {
			console.log(err);
			socket.emit('error', err);
		}
	});
}

/*
Save user code taken from Ace instance
*/
function saveCode (code) {
	storeFile(userData.codeCFile, code);
	storeFile(userData.codeTextFile, "var code=`" + code + "`;");
	eventEmitter.emit('codeSaved');
}

/*
run cc
*/
function compileCode(code) {
	state['runningFinished'] = false;
	saveCode(code);
	global.code = code;
	//
	exec (`${beekeeperData.ccPath} ${userData.codeCFile}`, (error1, stdout1, stderr1) => {
		if (error1 || stderr1) {
			console.error(`cc failed: ${error1}.`);
			socket.emit('message', "Compilation Failed");
		}
		else eventEmitter.emit('codeCompiled');
	});
}

/*
run samplesoc
*/
function copySoc() {
	exec (`cp -f ${beekeeperData.socPath} soc.json`, (error, stdout, stderr) => {
		if (error || stderr) {
			console.error(`Couldn't copy samplesoc: ${error}.`);
			socket.emit('error', error);
		}
		else eventEmitter.emit('socCopied');
	});
}

/*
run makesoc
*/
function makeSoc() {
	exec (`${beekeeperData.makeSocPath} soc.json`, (error, stdout, stderr) => {
		if (error || stderr) {
			console.error(`Couldn't makesoc: ${error}.`);
			socket.emit('error', {error});
		}
		else eventEmitter.emit('socMade');
	});
}

/*
build
*/
function build() {
	exec (`iverilog -o ${userData.codeCFile}.bin_dump/Beekeeper.vvp -I${beekeeperData.beekeeperPath} BFM.v`, (error3, stdout3, stderr3) => {
		if (error3 || stderr3) {
			console.error(`iverilog failed: ${error3}.`);
			socket.emit('error', error3);
		}
		else eventEmitter.emit('built');
	});
}

/*
Initialize the beekeeper process
*/
function runBeekeeper() {
	// If a beekeeper process is running, kill it
	if (procData.proc !== undefined) procData.proc.kill();
	// reset stepping to false if there was a previous run
	state.stepping = false;
	// remove any previous dump
	spawn('rm', ['-f', 'dump.vcd']);
	// vvp -M/usr/local/bin/BeekeeperSupport -mBeekeeper code.c.bin_dump/Beekeeper.vvp
	procData.proc = spawn('vvp', [`-M${beekeeperData.beekeeperPath}`, '-mBeekeeper', `${userData.codeCFile}.bin_dump/Beekeeper.vvp`]);
	eventEmitter.emit('ranBeekeeper');
}

/*
Set the program path for beekeeper and process communication
*/
function setProcessParams() {
	if (procData.proc != undefined) {
		procData.proc.stdin.setEncoding('utf-8');
		// set beekeeper program path
		procData.proc.stdin.write(`${userData.codeBinFile}\n`);
		// NOTE uncomment for debugging
		// procData.proc.stdout.pipe(process.stdout);
		eventEmitter.emit('processParamsSet');
	}
}

/*
TODO simplify this function
*/
function setBeekeeperDataStream() {
	procData.disassembly = "";
	procData.proc.stdout.on('data', (data) => {
		global.data = data;
		firstCapture = true;
		// convert data object to string
		data = "" + data;
		if (data.includes('Invalid input')) {
			socket.emit('message', `Sorry, you can't do that!`);
		}
		else if (data.includes('JAL zero, 0')) {
			state['runningFinished'] = true;
		} else {
			procData.processData = "" + data;
			procData.disassembly = data;
			// remove "(beekeeper)"
			procData.processData = procData.processData.substring(0, procData.processData.indexOf("(beekeeper)"));
			// Remove "Running step by step..."
			if (procData.processData.indexOf("Running") > -1) {
				procData.processData = procData.processData.substring(procData.processData.indexOf("Running") + "Running step by step...".length, procData.processData.length-1);
			}
			// get instructions
			var instruction = procData.processData.substring(0, procData.processData.indexOf("["));
			// get instruction address
			var address = procData.processData.substring(procData.processData.indexOf("["), procData.processData.indexOf("]"));
			// cleanup address
			if (address.indexOf(userData.codeFileName) > -1) {
				// get instruction line number
				state.step = parseInt(address.substring(address.indexOf(`${userData.codeFileName}:`) + `${userData.codeFileName}:`.length, address.indexOf(' ')));
				// get instruction address
				address = "[" + address.substring(address.indexOf(' ') + 1, address.length) + "]";
			}
			var lines = code.split('\n');
			// get the code line
			// TODO improve the loop
			for(var i = 0;i < lines.length;i++){
				if (state.step == i) procData.codeLine = lines[i];
			};
			// grab the instruction op
			var instructionSet = instruction.match(/[A-Z]+.*?,/g);
			// grab the instruction arguments
			var argumentSet = instruction.match(/(,[^A-Z]*)/g);
			var instructions = [];
			if (instructionSet != null) {
				for (var iterator = 0; iterator < instructionSet.length; iterator++) {
					instructions.push(instructionSet[iterator] + argumentSet[iterator].substring(1, argumentSet[iterator].length) + "<br/>")
				}
			}
			// create console text
			var text = "";
			if (instructions != null) {
				// line of code first, followed by address
				text = text + procData.codeLine + "<br/>" + address + "<br/>";
				// append instructions to text
				for (var iterator = 0; iterator < instructions.length; iterator++) {
					text = text + instructions[iterator];
				}
			}
			storeFile(userData.waveformTextFile, "var data=`" + text + "`;");
		}
	});
	eventEmitter.emit('dataStreamDefined');
}

function finishSave() {
	socket.emit('returnSaved');
}

function finishCompilation() {
	socket.emit('returnCompiled');
}

function finishStep() {
	storeVCD();
	socket.emit('returnStep');
}

function finishRun() {
	procData.proc.stdin.pause();
	procData.proc.kill();
	storeVCD();
}

function sendExitSignal() {
	socket.emit('returnStop');
}

// Where all socket.io communication to buttonInterface takes place
io.on("connection", function (socket) {
	// make socket object global
	global.socket = socket;

	// Once socket is initialized inform other party to proceed
	socket.emit('proceed', { state: 'fine' });

	// Save signal received when save button is pressed
	socket.on('save', function (code) {
		saveCode(code);
		eventEmitter.emit('codeSaved');
	});

	// Compile signal received when compile button is pressed
	socket.on('compile', function (code) {
		compileCode(code);
	});

	// Run signal received when run button is pressed
	socket.on('run', function(code) {
		if (state.stepping) procData.proc.stdin.write('continue\n');
		else procData.proc.stdin.write('run\n');
	});

	// Breakpoints signal received when breakpoints button is pressed and prompt complete
	socket.on('breakpoints', function(breakpoints) {
		// If breakpoints are 0 then they're at default and no points were set
		if (breakpoints != "0") {
			var number = 0;
			var breakArray = breakpoints.split(",");
			for (var i = 0; i < breakArray.length; i++) {
				number = parseInt(breakArray[i]);
				procData.proc.stdin.write(`break ${userData.codeCFile}:${number}\n`);
			}
		}
	});

	// Step signal received when step button is pressed
	socket.on('step', function(code) {
		state.stepping = true;
		procData.proc.stdin.write('step\n');
		eventEmitter.emit('stepFinished');
	});

	// Stepi signal received when step instruction button is pressed
	socket.on('stepi', function(code) {
		state.stepping = true;
		procData.proc.stdin.write('stepi\n');
		eventEmitter.emit('stepFinished');
	});

	// Stop signal received when stop button is pressed
	socket.on('stop', function(code) {
		if (procData.proc !== 'undefined') procData.proc.kill();
		eventEmitter.emit('stopped');
	});
});
